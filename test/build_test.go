package test

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"metis/util"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func makeSelectByID(table string, columns []Column) *ast.FuncDecl {
	fd := &ast.FuncDecl{
		Recv: makeRecv(),
		Name: makeSingleIdent(""),
	}
	return fd
}
func makeSelectByIDs(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeBatchSelectByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeSelectByName(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeInsert(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeBatchInsert(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeInsertNonNil(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeInsertWithFunc(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeBatchInsertWithFunc(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeDeleteByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeDeleteByIDs(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeBatchDeleteByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeUpdateByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeUpdateNonNilByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeUpdateWithFuncByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}
func makeBatchUpdateWithFuncByID(table string, columns []Column) *ast.FuncDecl {
	return nil
}

func makePkgDoc() *ast.CommentGroup {
	return &ast.CommentGroup{
		List: []*ast.Comment{
			{Text: "// Package account"},
			{Text: "// Code generated by tabuyos. DO NOT EDIT!"},
		},
	}
}

func makeImportSpec(path string) *ast.ImportSpec {
	return &ast.ImportSpec{
		Path: &ast.BasicLit{
			Kind:  token.STRING,
			Value: fmt.Sprintf("\"%s\"", path),
		},
	}
}

func makeImportDecl() *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{
			makeImportSpec("context"),
			makeImportSpec("database/sql"),
			makeImportSpec("errors"),
			makeImportSpec("fmt"),
			makeImportSpec("github.com/gin-gonic/gin"),
			makeImportSpec("go.uber.org/zap"),
			makeImportSpec("metis/config/constant"),
			makeImportSpec("metis/database"),
			makeImportSpec("metis/test/first/entity"),
			makeImportSpec("metis/test/first/model/dto"),
			makeImportSpec("metis/util"),
			makeImportSpec("metis/util/logger"),
			makeImportSpec("strings"),
		},
	}
}

func makeGetDbCtx() *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: makeRecv(),
		Name: makeSingleIdent("getDbCtx"),
		Type: makeFuncType(&ast.FieldList{}, makeSelectorExprResults("context", "Context")),
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.BasicLit{
							Kind:  token.STRING,
							Value: "context.WithValue(context.Background(), constant.TraceIdKey, ag.ctx.GetString(constant.TraceIdKey))",
						},
					},
					//Results: []ast.Expr{
					//	&ast.CallExpr{
					//		Fun: makeSelectorExpr("context", "WithValue"),
					//		Args: []ast.Expr{
					//			&ast.CallExpr{
					//				Fun: makeSelectorExpr("context", "Background"),
					//			},
					//			makeSelectorExpr("constant", "TraceIdKey"),
					//			&ast.CallExpr{
					//				Fun: &ast.SelectorExpr{
					//					X:   makeSelectorExpr("ag", "ctx"),
					//					Sel: makeSingleIdent("GetString"),
					//				},
					//				Args: []ast.Expr{
					//					makeSelectorExpr("constant", "TraceIdKey"),
					//				},
					//			},
					//		},
					//	},
					//},
				},
			},
		},
	}
}

func makeEllipsis(name string) *ast.Ellipsis {
	return &ast.Ellipsis{Elt: makeSingleIdent(name)}
}

func makeSingleIdent(name string) *ast.Ident {
	return &ast.Ident{Name: name}
}

func makeMultiIdent(names ...string) []*ast.Ident {
	idents := make([]*ast.Ident, len(names))
	for i, name := range names {
		idents[i] = &ast.Ident{Name: name}
	}
	return idents
}

func makeSelectorExpr(x, sel string) *ast.SelectorExpr {
	return &ast.SelectorExpr{
		X:   makeSingleIdent(x),
		Sel: makeSingleIdent(sel),
	}
}

func makeArrayTypeSelectorExpr(x, sel string) *ast.ArrayType {
	return &ast.ArrayType{
		Elt: &ast.SelectorExpr{
			X:   makeSingleIdent(x),
			Sel: makeSingleIdent(sel),
		}}
}

func makeArrayType(x string) *ast.ArrayType {
	return &ast.ArrayType{
		Elt: makeSingleIdent(x)}
}

func makeArrayTypeExpr(x, sel string) *ast.ArrayType {
	return &ast.ArrayType{
		Elt: makeStarExpr(x, sel)}
}

func makeField(t string, names ...string) *ast.Field {
	if len(names) == 0 {
		return &ast.Field{
			Type: makeSingleIdent(t),
		}
	}
	return &ast.Field{
		Names: makeMultiIdent(names...),
		Type:  makeSingleIdent(t),
	}
}

func makeEllipsisField(t string, names ...string) *ast.Field {
	if len(names) == 0 {
		return &ast.Field{
			Type: makeEllipsis(t),
		}
	}
	return &ast.Field{
		Names: makeMultiIdent(names...),
		Type:  makeEllipsis(t),
	}
}

func makeRecv() *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{{
			Names: makeNames("ag"),
			Type: &ast.StarExpr{
				X: makeSingleIdent("autoGen"),
			}}},
	}
}

func makeParams(t string, names ...string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{makeField(t, names...)},
	}
}

func makeEllipsisParams(t string, names ...string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{makeEllipsisField(t, names...)},
	}
}

func makeArrayTypeParams(t string, names ...string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{{Names: makeMultiIdent(names...), Type: makeArrayType(t)}},
	}
}

func makeResults(t string, names ...string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{makeField(t, names...)},
	}
}

func makeSelectorExprResults(x, sel string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{{Type: makeSelectorExpr(x, sel)}},
	}
}

func makeArrayTypeResults(x, sel string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{{Type: makeArrayTypeSelectorExpr(x, sel)}},
	}
}

func makeNames(names ...string) []*ast.Ident {
	return makeMultiIdent(names...)
}

func makeStarExpr(x, sel string) *ast.StarExpr {
	return &ast.StarExpr{
		X: makeSelectorExpr(x, sel),
	}
}

func makeFuncType(params *ast.FieldList, results *ast.FieldList) *ast.FuncType {
	return &ast.FuncType{
		Params:  params,
		Results: results,
	}
}

func makeMethod(fnName, comment string, params *ast.FieldList, results *ast.FieldList) *ast.Field {
	var commentGroup *ast.CommentGroup
	if comment != "" {
		commentGroup = &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Text: "// " + comment,
				},
			},
		}
	}
	return &ast.Field{
		Names: []*ast.Ident{
			{
				Name: fnName,
			},
		},
		Type: &ast.FuncType{
			Params:  params,
			Results: results,
		},
		Doc: commentGroup,
	}
}

func makeIAutoGen(table string) *ast.GenDecl {
	var fields []*ast.Field

	fields = append(fields, makeMethod(
		"SelectByID", "select by id",
		&ast.FieldList{
			List: []*ast.Field{makeField("int64", "id")},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeSelectorExpr("dto", table)}},
		}))
	fields = append(fields, makeMethod(
		"SelectByIDs", "",
		&ast.FieldList{
			List: []*ast.Field{makeEllipsisField("int64", "ids")},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeArrayTypeSelectorExpr("dto", table)}},
		}))
	fields = append(fields, makeMethod(
		"BatchSelectByID", "",
		&ast.FieldList{
			List: []*ast.Field{{Names: makeMultiIdent("ids"), Type: makeArrayType("int64")}},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeArrayTypeSelectorExpr("dto", table)}},
		}))
	fields = append(fields, makeMethod(
		"SelectByName", "",
		&ast.FieldList{
			List: []*ast.Field{makeField("string", "name")},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeArrayTypeSelectorExpr("dto", table)}},
		}))

	fields = append(fields, makeMethod(
		"Insert", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table)), Type: makeStarExpr("entity", table)},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("int64")},
		}))
	fields = append(fields, makeMethod(
		"BatchInsert", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table) + "s"), Type: makeArrayTypeExpr("entity", table)},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeArrayType("int64")}},
		}))
	fields = append(fields, makeMethod(
		"InsertNonNil", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table)), Type: makeStarExpr("entity", table)},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("int64")},
		}))
	fields = append(fields, makeMethod(
		"InsertWithFunc", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table)), Type: makeStarExpr("entity", table)},
				{Names: makeNames("fn"), Type: makeFuncType(&ast.FieldList{
					List: []*ast.Field{{Names: makeNames("f"), Type: makeSingleIdent("any")}},
				}, &ast.FieldList{
					List: []*ast.Field{{Type: makeSingleIdent("bool")}},
				})},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("int64")},
		}))
	fields = append(fields, makeMethod(
		"BatchInsertWithFunc", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table) + "s"), Type: makeArrayTypeExpr("entity", table)},
				{Names: makeNames("fn"), Type: makeFuncType(&ast.FieldList{
					List: []*ast.Field{{Names: makeNames("f"), Type: makeSingleIdent("any")}},
				}, &ast.FieldList{
					List: []*ast.Field{{Type: makeSingleIdent("bool")}},
				})},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeArrayType("int64")}},
		}))

	fields = append(fields, makeMethod(
		"DeleteByID", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				makeField("int64", "id"),
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("bool")},
		}))
	fields = append(fields, makeMethod(
		"DeleteByIDs", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				makeEllipsisField("int64", "ids"),
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("bool")},
		}))
	fields = append(fields, makeMethod(
		"BatchDeleteByID", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames("ids"), Type: makeArrayType("int64")},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("bool")},
		}))

	fields = append(fields, makeMethod(
		"UpdateByID", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table)), Type: makeStarExpr("entity", table)},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("bool")},
		}))
	fields = append(fields, makeMethod(
		"UpdateNonNilByID", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table)), Type: makeStarExpr("entity", table)},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("bool")},
		}))
	fields = append(fields, makeMethod(
		"UpdateWithFuncByID", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table)), Type: makeStarExpr("entity", table)},
				{Names: makeNames("fn"), Type: makeFuncType(&ast.FieldList{
					List: []*ast.Field{{Names: makeNames("f"), Type: makeSingleIdent("any")}},
				}, &ast.FieldList{
					List: []*ast.Field{{Type: makeSingleIdent("bool")}},
				})},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{makeField("bool")},
		}))
	fields = append(fields, makeMethod(
		"BatchUpdateWithFuncByID", "",
		&ast.FieldList{
			List: []*ast.Field{
				{Names: makeNames("tx"), Type: makeStarExpr("sql", "Tx")},
				{Names: makeNames(strings.ToLower(table) + "s"), Type: makeArrayTypeExpr("entity", table)},
				{Names: makeNames("fn"), Type: makeFuncType(&ast.FieldList{
					List: []*ast.Field{{Names: makeNames("f"), Type: makeSingleIdent("any")}},
				}, &ast.FieldList{
					List: []*ast.Field{{Type: makeSingleIdent("bool")}},
				})},
			},
		},
		&ast.FieldList{
			List: []*ast.Field{{Type: makeArrayType("bool")}},
		}))

	return &ast.GenDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: "// IAutoGen 基础接口"},
			},
		},
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: "IAutoGen",
				},
				Type: &ast.InterfaceType{
					Methods: &ast.FieldList{
						List: fields,
					},
				},
			},
		},
	}
}

func makeAutoGen() *ast.GenDecl {
	var fields []*ast.Field
	fields = append(fields, &ast.Field{
		Names: makeNames("ctx"),
		Type:  makeStarExpr("gin", "Context"),
	})
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: makeSingleIdent("autoGen"),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: fields,
					},
				},
			},
		},
	}
}

func TestGenRepository(t *testing.T) {
	autogenFilePath := "second/module/user/repository/account/autogen.go"
	if err := os.MkdirAll(filepath.Dir(autogenFilePath), 0766); err != nil {
		panic(err)
	}
	wr, err := os.OpenFile(autogenFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		panic(err)
	}
	defer util.DeferClose(wr)

	pkgDoc := "// Package account\n// Code generated by tabuyos. DO NOT EDIT！\n// @author tabuyos\n// @since 2023/7/29\n// @description account\n"
	repoFile := &ast.File{
		Package: token.Pos(len(pkgDoc) + 1),
		Name: &ast.Ident{
			Name:    "account",
			NamePos: token.Pos(len("package") + 2),
		}}

	fileSet := token.NewFileSet()

	repoFile.Decls = append(repoFile.Decls, makeImportDecl())
	repoFile.Decls = append(repoFile.Decls, makeIAutoGen("Account"))
	repoFile.Decls = append(repoFile.Decls, makeAutoGen())
	repoFile.Decls = append(repoFile.Decls, makeGetDbCtx())

	if _, err := wr.Write([]byte(pkgDoc)); err != nil {
		panic(err)
	}
	if err := format.Node(wr, fileSet, repoFile); err != nil {
		panic(err)
	}

}
