// Package account
// Code generated by tabuyos. DO NOT EDIT！
// @author tabuyos
// @since 2023/7/29
// @description account
package account

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"metis/config/constant"
	"metis/database"
	"metis/test/first/entity"
	"metis/test/first/model/dto"
	"metis/util"
	"metis/util/logger"
	"strings"
)

// IAutoGen 基础接口
type IAutoGen interface {
	SelectByID(id int64) dto.Account
	SelectByIDs(ids ...int64) []dto.Account
	BatchSelectByID(ids []int64) []dto.Account
	SelectByName(name string) []dto.Account

	Insert(tx *sql.Tx, account *entity.Account) int64
	BatchInsert(tx *sql.Tx, accounts []*entity.Account) []int64
	InsertNonNil(tx *sql.Tx, account *entity.Account) int64
	InsertWithFunc(tx *sql.Tx, account *entity.Account, fn func(f any) bool) int64
	BatchInsertWithFunc(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) []int64

	DeleteByID(tx *sql.Tx, id int64) bool
	DeleteByIDs(tx *sql.Tx, ids ...int64) bool
	BatchDeleteByID(tx *sql.Tx, ids []int64) bool

	UpdateByID(tx *sql.Tx, account *entity.Account) bool
	UpdateNonNilByID(tx *sql.Tx, account *entity.Account) bool
	UpdateWithFuncByID(tx *sql.Tx, account *entity.Account, fn func(f any) bool) bool
	BatchUpdateWithFuncByID(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) bool
}

type autoGen struct {
	ctx *gin.Context
}

func (ag *autoGen) getDbCtx() context.Context {
	return context.WithValue(context.Background(), constant.TraceIdKey, ag.ctx.GetString(constant.TraceIdKey))
}

// SelectByID ok
func (ag *autoGen) SelectByID(id int64) dto.Account {
	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()

	sqlPlaceholder := "SELECT id, title, name FROM account WHERE id = ?;"

	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))

	row := prepare.QueryRowContext(ag.getDbCtx(), id)

	account := util.Row(row, func() (*dto.Account, []any) {
		var r = &dto.Account{}
		var cs = []any{&r.ID, &r.Title, &r.Name}
		return r, cs
	})

	return account
}

// SelectByIDs ok
func (ag *autoGen) SelectByIDs(ids ...int64) []dto.Account {
	return ag.BatchSelectByID(ids)
}

// BatchSelectByID ok
func (ag *autoGen) BatchSelectByID(ids []int64) []dto.Account {
	placeholder := make([]string, len(ids))

	for i := 0; i < len(ids); i++ {
		placeholder[i] = "?"
	}

	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()

	sqlPlaceholder := fmt.Sprintf("SELECT id, title, name FROM account WHERE id IN (%s);", strings.Join(placeholder, ", "))

	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))

	bindValues := make([]any, len(ids))
	for i, id := range ids {
		bindValues[i] = id
	}
	rows, err := prepare.QueryContext(ag.getDbCtx(), bindValues...)

	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}

	accounts := util.Rows(rows, func() (*dto.Account, []any) {
		var r = &dto.Account{}
		var cs = []any{&r.ID, &r.Title, &r.Name}
		return r, cs
	})

	return accounts
}

// SelectByName ok
func (ag *autoGen) SelectByName(name string) []dto.Account {

	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()

	sqlPlaceholder := "SELECT id, title, name FROM account WHERE name LIKE ?;"

	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))

	rows, err := prepare.QueryContext(ag.getDbCtx(), name)

	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}

	accounts := util.Rows(rows, func() (*dto.Account, []any) {
		var r = &dto.Account{}
		var cs = []any{&r.ID, &r.Title, &r.Name}
		return r, cs
	})

	return accounts
}

// internalInsert ok
func (ag *autoGen) internalInsert(prepare *sql.Stmt, account *entity.Account) int64 {
	recorder := logger.AccessLogger(ag.ctx)

	result, err := prepare.ExecContext(ag.getDbCtx(), *account.ID, *account.Name, *account.Title)
	util.PanicErr(recorder, err)

	id, err := result.LastInsertId()
	util.PanicErr(recorder, err)

	return id
}

// Insert ok
func (ag *autoGen) Insert(tx *sql.Tx, account *entity.Account) int64 {
	recorder := logger.AccessLogger(ag.ctx)

	sqlPlaceholder := "INSERT INTO account(id, name, title) VALUES (?, ?, ?);"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))
	util.PanicErr(recorder, err)

	return ag.internalInsert(prepare, account)
}

// BatchInsert ok
func (ag *autoGen) BatchInsert(tx *sql.Tx, accounts []*entity.Account) []int64 {
	retids := make([]int64, len(accounts))
	recorder := logger.AccessLogger(ag.ctx)

	sqlPlaceholder := "INSERT INTO account(id, name, title) VALUES (?, ?, ?);"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))
	util.PanicErr(recorder, err)

	for i, account := range accounts {
		retids[i] = ag.internalInsert(prepare, account)
	}

	return retids
}

func (ag *autoGen) InsertNonNil(tx *sql.Tx, account *entity.Account) int64 {
	return ag.InsertWithFunc(tx, account, func(f any) bool {
		return f != nil
	})
}

func (ag *autoGen) InsertWithFunc(tx *sql.Tx, account *entity.Account, fn func(f any) bool) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	var needField strings.Builder
	var needPlace strings.Builder
	var bindValue []any

	if fn(account.ID) {
		needField.WriteString("id, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *account.ID)
	}

	if fn(account.Name) {
		needField.WriteString("name, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *account.Name)
	}

	if fn(account.Title) {
		needField.WriteString("title, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *account.Title)
	}

	sqlPlaceholder := fmt.Sprintf(
		"INSERT INTO account(%s) VALUES (%s);",
		needField.String()[:needField.Len()-2],
		needPlace.String()[:needPlace.Len()-2])
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))
	util.PanicErr(recorder, err)

	return ag.internalInsert(prepare, account)
}

func (ag *autoGen) BatchInsertWithFunc(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) []int64 {
	retids := make([]int64, len(accounts))
	for i, account := range accounts {
		retids[i] = ag.InsertWithFunc(tx, account, fn)
	}
	return retids
}

// DeleteByID ok
func (ag *autoGen) DeleteByID(tx *sql.Tx, id int64) bool {
	recorder := logger.AccessLogger(ag.ctx)

	sqlPlaceholder := "DELETE FROM account WHERE id = ?;"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))
	util.PanicErr(recorder, err)

	result, err := prepare.ExecContext(ag.getDbCtx(), id)
	util.PanicErr(recorder, err)

	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)

	return af == 1
}

// DeleteByIDs ok
func (ag *autoGen) DeleteByIDs(tx *sql.Tx, ids ...int64) bool {
	return ag.BatchDeleteByID(tx, ids)
}

// BatchDeleteByID ok
func (ag *autoGen) BatchDeleteByID(tx *sql.Tx, ids []int64) bool {
	placeholder := make([]string, len(ids))

	for i := 0; i < len(ids); i++ {
		placeholder[i] = "?"
	}

	recorder := logger.AccessLogger(ag.ctx)

	sqlPlaceholder := fmt.Sprintf("DELETE FROM account WHERE id IN (%s);", strings.Join(placeholder, ", "))

	prepare, _ := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))

	bindValues := make([]any, len(ids))
	for i, id := range ids {
		bindValues[i] = id
	}
	result, err := prepare.ExecContext(ag.getDbCtx(), bindValues...)

	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}

	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)

	return af == int64(len(ids))
}

// UpdateByID ok
func (ag *autoGen) UpdateByID(tx *sql.Tx, account *entity.Account) bool {
	recorder := logger.AccessLogger(ag.ctx)

	sqlPlaceholder := "UPDATE account SET name = ?, title = ? WHERE id = ?;"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))
	util.PanicErr(recorder, err)

	result, err := prepare.ExecContext(ag.getDbCtx(), *account.Name, *account.Title, *account.ID)
	util.PanicErr(recorder, err)

	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)

	return af == 1
}

// UpdateNonNilByID ok
func (ag *autoGen) UpdateNonNilByID(tx *sql.Tx, account *entity.Account) bool {
	return ag.UpdateWithFuncByID(tx, account, func(f any) bool {
		return f == nil
	})
}

// UpdateWithFuncByID ok
func (ag *autoGen) UpdateWithFuncByID(tx *sql.Tx, account *entity.Account, fn func(f any) bool) bool {
	recorder := logger.AccessLogger(ag.ctx)
	if account.ID == nil {
		util.PanicErr(recorder, errors.New("ID is nil"))
	}
	var needFieldAndPlace strings.Builder
	var bindValue []any

	if fn(account.Name) {
		needFieldAndPlace.WriteString("name = ?, ")
		bindValue = append(bindValue, *account.Name)
	}

	if fn(account.Title) {
		needFieldAndPlace.WriteString("title = ?, ")
		bindValue = append(bindValue, *account.Title)
	}

	bindValue = append(bindValue, *account.ID)

	sqlPlaceholder := fmt.Sprintf(
		"UPDATE account SET %s WHERE id = ?;",
		needFieldAndPlace.String()[:needFieldAndPlace.Len()-2])
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLogAndPanic(recorder))
	util.PanicErr(recorder, err)

	result, err := prepare.ExecContext(ag.getDbCtx(), bindValue...)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)

	return af == 1
}

// BatchUpdateWithFuncByID ok
func (ag *autoGen) BatchUpdateWithFuncByID(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) bool {
	recorder := logger.AccessLogger(ag.ctx)
	af := false

	for _, account := range accounts {
		af = ag.UpdateWithFuncByID(tx, account, fn)
		if af {
			continue
		}
		util.PanicErr(recorder, errors.New("some entry update failed"))
		break
	}
	return af
}
