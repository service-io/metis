// Package role
// Code generated by tabuyos. DO NOT EDIT！
// @author tabuyos
// @since 2023/7/29
// @description role
package role

import (
	"context"
	"database/sql"
	"github.com/gin-gonic/gin"
	"metis/config/constant"
	"metis/database"
	"metis/test/first/entity"
	"metis/util"
	"metis/util/logger"
	"strings"
)

//

// IAutoGen 基础接口
type IAutoGen interface {
	// SelectByID 所有的 select 均最终调用 BatchSelectByID
	SelectByID(id int64) *entity.Role
	SelectByIDs(ids ...int64) []*entity.Role
	BatchSelectByID(ids []int64) []*entity.Role

	SelectByName(name string) []*entity.Role

	SelectMaxLevel(treeNo int) int
	SelectMaxRight(treeNo int) int
	SelectMaxLeft(treeNo int) int
	SelectMaxTreeNo() int
	// SelectAllPosterity 所有子代
	SelectAllPosterity(id int64) []*entity.Role
	// SelectDirectPosterity 直系子代
	SelectDirectPosterity(id int64) []*entity.Role
	// SelectBrother 兄弟
	SelectBrother(id int64) []*entity.Role
	// SelectBrotherAndSelf 兄弟以及自身
	SelectBrotherAndSelf(id int64) []*entity.Role
	// SelectAncestorChain 获取祖链(含自身)
	SelectAncestorChain(id int64) []*entity.Role
	// SelectAncestor 获取祖籍节点
	SelectAncestor(id int64, level int) *entity.Role
	// SelectParent 获取父级节点
	SelectParent(id int64) *entity.Role
	// SelectByTreeNoAndLevel 获取父级节点
	SelectByTreeNoAndLevel(treeNo, level int) []*entity.Role
	SelectByLevel(level int) []*entity.Role
	SelectRoot(id int64) *entity.Role
	SelectLeaf(id int64, page, size uint) ([]*entity.Role, int64)
	SelectAllLeaf(id int64) []*entity.Role
	SelectAllRoot() []*entity.Role

	// Insert 所有的 insert 均最终调用 BatchInsertWithFunc
	Insert(tx *sql.Tx, role *entity.Role) int64
	InsertUnderNode(tx *sql.Tx, role *entity.Role, pid int64) int64
	InsertBetweenNode(tx *sql.Tx, role *entity.Role, pid, sid int64) int64

	BatchInsert(tx *sql.Tx, roles []*entity.Role) []int64
	BatchInsertUnderNode(tx *sql.Tx, roles []*entity.Role, pid int64) []int64
	BatchInsertBetweenNode(tx *sql.Tx, roles []*entity.Role, pid, sid int64) []int64

	InsertNonNil(tx *sql.Tx, role *entity.Role) int64
	InsertNonNilUnderNode(tx *sql.Tx, role *entity.Role, pid int64) int64
	InsertNonNilBetweenNode(tx *sql.Tx, role *entity.Role, pid, sid int64) int64

	InsertWithFunc(tx *sql.Tx, role *entity.Role, fn func(f any) bool) int64
	InsertWithFuncUnderNode(tx *sql.Tx, role *entity.Role, pid int64, fn func(f any) bool) int64
	InsertWithFuncBetweenNode(tx *sql.Tx, role *entity.Role, pid, sid int64, fn func(f any) bool) int64

	BatchInsertWithFunc(tx *sql.Tx, roles []*entity.Role, pid, sid int64, fn func(f any) bool) []int64

	// DeleteByID 所有的 delete 均最终调用 BatchDeleteByID
	DeleteByID(tx *sql.Tx, id int64) bool
	DeleteByIDs(tx *sql.Tx, ids ...int64) bool
	BatchDeleteByID(tx *sql.Tx, ids []int64) bool

	// UpdateByID 所有的 update 均最终调用 BatchUpdateWithFuncByID
	UpdateByID(tx *sql.Tx, role *entity.Role) bool
	UpdateNonNilByID(tx *sql.Tx, role *entity.Role) bool
	UpdateWithFuncByID(tx *sql.Tx, role *entity.Role, fn func(f any) bool) bool
	BatchUpdateWithFuncByID(tx *sql.Tx, roles []*entity.Role, fn func(f any) bool) bool

	SwitchNode(fromId, toId int64) bool
}

type autoGen struct {
	ctx *gin.Context
}

// func NewAg() IAutoGen {
// 	return &autoGen{}
// }

func mapperAll() (*entity.Role, []any) {
	var r = &entity.Role{}
	var cs = []any{&r.ID}
	return r, cs
}

func mapperNumeric[T int | int64]() (*T, []any) {
	var r T
	var cs = []any{&r}
	return &r, cs
}

func allFields() string {
	return "<fields>"
}

func treeFields() string {
	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString("<l_key>, ")
	sqlBuilder.WriteString("<r_key>, ")
	sqlBuilder.WriteString("<tn_key> ")
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<p_key> ")
	sqlBuilder.WriteString("= ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")
	return sqlBuilder.String()
}

func calcInsertField(role *entity.Role, fn func(f any) bool) (string, string, []any) {
	var fields []string
	var values []any
	var places []string
	if fn(role.ID) {
		fields = append(fields, "<id>")
		places = append(places, "?")
	}
	return strings.Join(fields, ", "), strings.Join(places, ", "), values
}

func (ag *autoGen) internalSelectNodeByID(tx *sql.Tx, db *sql.DB, ids []int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID 列表: %+v 的数据", ids)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<p_key> ")
	if len(ids) == 1 {
		sqlBuilder.WriteString("= ?")
	} else {
		sqlBuilder.WriteString("in (")
		sqlBuilder.WriteString(util.GenPlaceholder(ids))
		sqlBuilder.WriteString(")")
	}
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	var stmt *sql.Stmt
	var err error
	if tx != nil {
		stmt, err = tx.Prepare(sqlBuilder.String())
		defer util.DeferClose(stmt, errorHandler)
		errorHandler(err)
	} else {
		stmt, err = db.Prepare(sqlBuilder.String())
		defer util.DeferClose(stmt, errorHandler)
		errorHandler(err)
	}
	bindValues := util.ToAnyItems(ids)
	rows, err := stmt.QueryContext(ag.getDbCtx(), bindValues...)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) internalDirectInsert(tx *sql.Tx, role *entity.Role, fn func(f any) bool) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	if role.TreeNo == nil {
		panic("需要填充树号")
	}
	if role.Left == nil {
		panic("需要填充左值")
	}
	if role.Right == nil {
		panic("需要填充右值")
	}
	if role.Level == nil {
		panic("需要填充层级")
	}

	fields, places, values := calcInsertField(role, fn)
	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("insert ")
	sqlBuilder.WriteString("into ")
	sqlBuilder.WriteString("<table>(")
	sqlBuilder.WriteString(fields)
	sqlBuilder.WriteString(") ")
	sqlBuilder.WriteString("values (")
	sqlBuilder.WriteString(places)
	sqlBuilder.WriteString(")")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	stmt, err := tx.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	result, err := stmt.ExecContext(ag.getDbCtx(), values...)
	errorHandler(err)
	af, err := result.RowsAffected()
	errorHandler(err)
	id, err := result.LastInsertId()
	errorHandler(err)
	if af == 1 {
		return id
	}
	panic("插入失败")
}

func (ag autoGen) internalUpdateNodeInBothWhenInsert(tx *sql.Tx, left, right, treeNo int) {
	recorder := logger.AccessLogger(ag.ctx)
	var firstSqlBuilder strings.Builder
	firstSqlBuilder.WriteString("update ")
	firstSqlBuilder.WriteString("<table>")
	firstSqlBuilder.WriteString("set <l_key> = <l_key> + 2 ")
	firstSqlBuilder.WriteString("where ")
	firstSqlBuilder.WriteString("<l_key> > ? and")
	firstSqlBuilder.WriteString("<tn_key> = ?")
	firstSqlBuilder.WriteString("<deleted_cond>")
	firstSqlBuilder.WriteString(";")

	var secondSqlBuilder strings.Builder
	secondSqlBuilder.WriteString("update ")
	secondSqlBuilder.WriteString("<table>")
	secondSqlBuilder.WriteString("set <r_key> = <r_key> + 2 ")
	secondSqlBuilder.WriteString("where ")
	secondSqlBuilder.WriteString("<r_key> >= ? and")
	secondSqlBuilder.WriteString("<tn_key> = ?")
	secondSqlBuilder.WriteString("<deleted_cond>")
	secondSqlBuilder.WriteString(";")

	var thirdSqlBuilder strings.Builder
	thirdSqlBuilder.WriteString("update ")
	thirdSqlBuilder.WriteString("<table>")
	thirdSqlBuilder.WriteString("set <l_key> = <l_key> + 1 ")
	thirdSqlBuilder.WriteString("<r_key> = <r_key> + 1 ")
	thirdSqlBuilder.WriteString("<ll_key> = <ll_key> + 1 ")
	thirdSqlBuilder.WriteString("where ")
	thirdSqlBuilder.WriteString("<l_key> >= ? and")
	thirdSqlBuilder.WriteString("<r_key> <= ? and")
	thirdSqlBuilder.WriteString("<tn_key> = ?")
	thirdSqlBuilder.WriteString("<deleted_cond>")
	thirdSqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)

	stmt, err := tx.Prepare(firstSqlBuilder.String())
	errorHandler(err)
	result, err := stmt.ExecContext(ag.getDbCtx(), right, treeNo)
	errorHandler(err)
	_, err = result.RowsAffected()
	errorHandler(err)

	stmt, err = tx.Prepare(secondSqlBuilder.String())
	errorHandler(err)
	result, err = stmt.ExecContext(ag.getDbCtx(), right, treeNo)
	errorHandler(err)
	_, err = result.RowsAffected()
	errorHandler(err)

	stmt, err = tx.Prepare(thirdSqlBuilder.String())
	errorHandler(err)
	result, err = stmt.ExecContext(ag.getDbCtx(), left, right, treeNo)
	errorHandler(err)
	_, err = result.RowsAffected()
	errorHandler(err)
}

func (ag *autoGen) internalUpdateNodeInOnlyPrecursorWhenInsert(tx *sql.Tx, right, treeNo int) {
	recorder := logger.AccessLogger(ag.ctx)
	var firstSqlBuilder strings.Builder
	firstSqlBuilder.WriteString("update ")
	firstSqlBuilder.WriteString("<table>")
	firstSqlBuilder.WriteString("set <l_key> = <l_key> + 2 ")
	firstSqlBuilder.WriteString("where ")
	firstSqlBuilder.WriteString("<l_key> > ? and")
	firstSqlBuilder.WriteString("<tn_key> = ?")
	firstSqlBuilder.WriteString("<deleted_cond>")
	firstSqlBuilder.WriteString(";")

	var secondSqlBuilder strings.Builder
	secondSqlBuilder.WriteString("update ")
	secondSqlBuilder.WriteString("<table>")
	secondSqlBuilder.WriteString("set <r_key> = <r_key> + 2 ")
	secondSqlBuilder.WriteString("where ")
	secondSqlBuilder.WriteString("<r_key> >= ? and")
	secondSqlBuilder.WriteString("<tn_key> = ?")
	secondSqlBuilder.WriteString("<deleted_cond>")
	secondSqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)

	stmt, err := tx.Prepare(firstSqlBuilder.String())
	errorHandler(err)
	result, err := stmt.ExecContext(ag.getDbCtx(), right, treeNo)
	errorHandler(err)
	_, err = result.RowsAffected()
	errorHandler(err)

	stmt, err = tx.Prepare(secondSqlBuilder.String())
	errorHandler(err)
	result, err = stmt.ExecContext(ag.getDbCtx(), right, treeNo)
	errorHandler(err)
	_, err = result.RowsAffected()
	errorHandler(err)
}

func (ag *autoGen) internalInsertWithFunc(tx *sql.Tx, role *entity.Role, pid, sid int64, fn func(f any) bool) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("插入节点, 前驱: %+v, 后继: %+v, 节点: %+v", pid, sid, *role)

	if pid == 0 {
		// 无前驱节点, 同时一定无后继, 必须先有前驱才能有后继
		// 所以该节点一定是根节点

		// 直接插入
		ag.internalDirectInsert(tx, role, fn)
	}

	precursorNodes := ag.internalSelectNodeByID(tx, nil, []int64{pid})
	if len(precursorNodes) == 1 {
		precursor := precursorNodes[0]
		role.TreeNo = precursor.TreeNo
		level := *precursor.Level + 1
		role.Level = &level

		// 有前驱, 无后继节点, 则说明插入的是叶子节点, 需要更新链路上插入点后的所有节点
		if sid == 0 {
			right := *precursor.Right + 1
			role.Left = precursor.Right
			role.Right = &right

			ag.internalUpdateNodeInOnlyPrecursorWhenInsert(tx, *precursor.Right, *precursor.TreeNo)
			ag.internalDirectInsert(tx, role, fn)
		} else {
			successorNodes := ag.internalSelectNodeByID(tx, nil, []int64{pid})
			if len(successorNodes) == 1 {
				successor := successorNodes[0]
				right := *successor.Right + 2
				role.Left = successor.Left
				role.Right = &right

				ag.internalUpdateNodeInBothWhenInsert(tx, *successor.Left, *successor.Right, *successor.TreeNo)
				ag.internalDirectInsert(tx, role, fn)
			} else if len(successorNodes) == 0 {
				panic("不存在后继节点")
			}
			panic("存在多个后继节点")
		}

	} else if len(precursorNodes) == 0 {
		panic("不存在前驱节点")
	}
	panic("存在多个前驱节点")
}

func (ag *autoGen) getDbCtx() context.Context {
	return context.WithValue(context.Background(), constant.TraceIdKey, ag.ctx.GetString(constant.TraceIdKey))
}

func (ag *autoGen) SelectByID(id int64) *entity.Role {
	ds := ag.BatchSelectByID([]int64{id})
	if len(ds) == 1 {
		return ds[0]
	}
	return nil
}

func (ag *autoGen) SelectByIDs(ids ...int64) []*entity.Role {
	ds := ag.BatchSelectByID(ids)
	return ds
}

func (ag *autoGen) BatchSelectByID(ids []int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID 列表: %+v 的数据", ids)

	db := database.FetchDB()
	return ag.internalSelectNodeByID(nil, db, ids)
}

func (ag *autoGen) SelectByName(name string) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 NAME: %+v 的数据", name)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<name_key> ")
	sqlBuilder.WriteString("like ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	db := database.FetchDB()
	errorHandler := util.ErrToLogAndPanic(recorder)
	stmt, err := db.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	rows, err := stmt.QueryContext(ag.getDbCtx(), name)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectMaxLevel(treeNo int) int {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 TN: %+v 的最大层级", treeNo)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString("max(<ll_key>)")
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<tn_key> ")
	sqlBuilder.WriteString("= ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	db := database.FetchDB()
	errorHandler := util.ErrToLogAndPanic(recorder)
	stmt, err := db.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	row := stmt.QueryRowContext(ag.getDbCtx(), treeNo)
	ds := util.Row(row, mapperNumeric[int])
	return *ds
}

func (ag *autoGen) SelectMaxRight(treeNo int) int {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 TN: %+v 的最大层级", treeNo)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString("max(<r_key>)")
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<tn_key> ")
	sqlBuilder.WriteString("= ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	db := database.FetchDB()
	errorHandler := util.ErrToLogAndPanic(recorder)
	stmt, err := db.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	row := stmt.QueryRowContext(ag.getDbCtx(), treeNo)
	ds := util.Row(row, mapperNumeric[int])
	return *ds
}

func (ag *autoGen) SelectMaxLeft(treeNo int) int {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 TN: %+v 的最大层级", treeNo)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString("max(<l_key>)")
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<tn_key> ")
	sqlBuilder.WriteString("= ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	db := database.FetchDB()
	errorHandler := util.ErrToLogAndPanic(recorder)
	stmt, err := db.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	row := stmt.QueryRowContext(ag.getDbCtx(), treeNo)
	ds := util.Row(row, mapperNumeric[int])
	return *ds
}

func (ag *autoGen) SelectMaxTreeNo() int {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Info("查询最大TN")

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString("max(<tn_key>)")
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<tn_key> ")
	sqlBuilder.WriteString("= ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	db := database.FetchDB()
	row := db.QueryRowContext(ag.getDbCtx(), sqlBuilder.String())
	ds := util.Row(row, mapperNumeric[int])
	return *ds
}

func (ag *autoGen) SelectAllPosterity(id int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的所有子代(含自身)数据", id)
	// recorder.Warn("不建议查询全部子代, 如果树比较大, 数据量将会非常大")

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<l_key> > ? and ")
	sqlBuilder.WriteString("<r_key> < ? and")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, *currentNode.TreeNo)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectDirectPosterity(id int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的直系子代数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = ? and ")
	sqlBuilder.WriteString("<l_key> > ? and ")
	sqlBuilder.WriteString("<r_key> < ? and")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Level+1, *currentNode.Left, *currentNode.Right, *currentNode.TreeNo)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectBrother(id int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的兄弟数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = ? and ")
	sqlBuilder.WriteString("<tn_key> = ? and ")
	sqlBuilder.WriteString("<p_key> != ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Level+1, *currentNode.TreeNo, id)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectBrotherAndSelf(id int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的兄弟以及自身数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = ? and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Level+1, *currentNode.TreeNo)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectAncestorChain(id int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的祖链数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<l_key> < ? and ")
	sqlBuilder.WriteString("<r_key> > ? and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, *currentNode.TreeNo)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectAncestor(id int64, level int) *entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的祖代(%+v)数据", id, level)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<l_key> < ? and ")
	sqlBuilder.WriteString("<r_key> > ? and ")
	sqlBuilder.WriteString("<ll_key> = ? and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	row = secondStmt.QueryRowContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, level, *currentNode.TreeNo)
	ds := util.Row(row, mapperAll)
	return ds
}

func (ag *autoGen) SelectParent(id int64) *entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的父节点数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<l_key> < ? and ")
	sqlBuilder.WriteString("<r_key> > ? and ")
	sqlBuilder.WriteString("<ll_key> = ? and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	row = secondStmt.QueryRowContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, *currentNode.Level-1, *currentNode.TreeNo)
	ds := util.Row(row, mapperAll)
	return ds
}

func (ag *autoGen) SelectByTreeNoAndLevel(treeNo, level int) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 TN: %+v LL: %+v 的同代数据", treeNo, level)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = ? and")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()

	stmt, err := db.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	rows, err := stmt.QueryContext(ag.getDbCtx(), treeNo, level)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectByLevel(level int) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 LL: %+v 的同代(跨树)数据", level)

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = ? and")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()

	stmt, err := db.Prepare(sqlBuilder.String())
	defer util.DeferClose(stmt, errorHandler)
	errorHandler(err)
	rows, err := stmt.QueryContext(ag.getDbCtx(), level)
	errorHandler(err)
	defer util.DeferClose(rows, errorHandler)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectRoot(id int64) *entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的根节点数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = 1 and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	row = secondStmt.QueryRowContext(ag.getDbCtx(), *currentNode.TreeNo)
	ds := util.Row(row, mapperAll)
	return ds
}

func (ag *autoGen) SelectLeaf(id int64, page, size uint) ([]*entity.Role, int64) {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("分页查询 ID: %+v 的叶子节点数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<l_key> >= ? and ")
	sqlBuilder.WriteString("<r_key> <= ? and ")
	sqlBuilder.WriteString("<l_key> + 1 = <r_key> and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")

	var noCondSql = sqlBuilder.String() + ";"

	sqlBuilder.WriteString(" limit ?")
	sqlBuilder.WriteString(" offset ?")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, *currentNode.TreeNo, size, (page-1)*size)
	errorHandler(err)
	ds := util.Rows(rows, mapperAll)

	thirdStmt, err := tx.Prepare(noCondSql)
	errorHandler(err)
	defer util.DeferClose(thirdStmt, errorHandler)
	row = thirdStmt.QueryRowContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, *currentNode.TreeNo)
	total := util.Row(row, mapperNumeric[int64])
	return ds, *total
}

func (ag *autoGen) SelectAllLeaf(id int64) []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Sugar().Infof("查询 ID: %+v 的所有叶子节点数据", id)

	treeInfoSql := treeFields()

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<l_key> >= ? and ")
	sqlBuilder.WriteString("<r_key> <= ? and ")
	sqlBuilder.WriteString("<l_key> + 1 = <r_key> and ")
	sqlBuilder.WriteString("<tn_key> = ?")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()
	tx, err := db.Begin()
	defer util.HandleTx(tx, errorHandler)
	errorHandler(err)
	firstStmt, err := tx.Prepare(treeInfoSql)
	defer util.DeferClose(firstStmt, errorHandler)
	errorHandler(err)
	row := firstStmt.QueryRowContext(ag.getDbCtx(), id)
	currentNode := util.Row(row, mapperAll)

	secondStmt, err := tx.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(secondStmt, errorHandler)
	rows, err := secondStmt.QueryContext(ag.getDbCtx(), *currentNode.Left, *currentNode.Right, *currentNode.TreeNo)
	errorHandler(err)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) SelectAllRoot() []*entity.Role {
	recorder := logger.AccessLogger(ag.ctx)
	recorder.Info("查询的所有根节点数据")

	var sqlBuilder strings.Builder
	sqlBuilder.WriteString("select ")
	sqlBuilder.WriteString(allFields())
	sqlBuilder.WriteString("from <table> ")
	sqlBuilder.WriteString("where ")
	sqlBuilder.WriteString("<ll_key> = 1")
	sqlBuilder.WriteString("<deleted_cond>")
	sqlBuilder.WriteString(";")

	errorHandler := util.ErrToLogAndPanic(recorder)
	db := database.FetchDB()

	stmt, err := db.Prepare(sqlBuilder.String())
	errorHandler(err)
	defer util.DeferClose(stmt, errorHandler)
	rows, err := stmt.QueryContext(ag.getDbCtx())
	errorHandler(err)
	ds := util.Rows(rows, mapperAll)
	return ds
}

func (ag *autoGen) Insert(tx *sql.Tx, role *entity.Role) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, 0, 0, func(f any) bool {
		return true
	})
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertUnderNode(tx *sql.Tx, role *entity.Role, pid int64) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, pid, 0, func(f any) bool {
		return true
	})
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertBetweenNode(tx *sql.Tx, role *entity.Role, pid, sid int64) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, pid, sid, func(f any) bool {
		return true
	})
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) BatchInsert(tx *sql.Tx, roles []*entity.Role) []int64 {
	ids := ag.BatchInsertWithFunc(tx, roles, 0, 0, func(f any) bool {
		return true
	})
	if len(ids) == len(roles) {
		return ids
	}
	panic("插入失败, 仅返回记录数等于插入记录数时成功")
}

func (ag *autoGen) BatchInsertUnderNode(tx *sql.Tx, roles []*entity.Role, pid int64) []int64 {
	ids := ag.BatchInsertWithFunc(tx, roles, pid, 0, func(f any) bool {
		return true
	})
	if len(ids) == len(roles) {
		return ids
	}
	panic("插入失败, 仅返回记录数等于插入记录数时成功")
}

func (ag *autoGen) BatchInsertBetweenNode(tx *sql.Tx, roles []*entity.Role, pid, sid int64) []int64 {
	ids := ag.BatchInsertWithFunc(tx, roles, pid, sid, func(f any) bool {
		return true
	})
	if len(ids) == len(roles) {
		return ids
	}
	panic("插入失败, 仅返回记录数等于插入记录数时成功")
}

func (ag *autoGen) InsertNonNil(tx *sql.Tx, role *entity.Role) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, 0, 0, func(f any) bool {
		return f != nil
	})
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertNonNilUnderNode(tx *sql.Tx, role *entity.Role, pid int64) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, pid, 0, func(f any) bool {
		return f != nil
	})
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertNonNilBetweenNode(tx *sql.Tx, role *entity.Role, pid, sid int64) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, pid, sid, func(f any) bool {
		return f != nil
	})
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertWithFunc(tx *sql.Tx, role *entity.Role, fn func(f any) bool) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, 0, 0, fn)
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertWithFuncUnderNode(tx *sql.Tx, role *entity.Role, pid int64, fn func(f any) bool) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, pid, 0, fn)
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) InsertWithFuncBetweenNode(tx *sql.Tx, role *entity.Role, pid, sid int64, fn func(f any) bool) int64 {
	ids := ag.BatchInsertWithFunc(tx, []*entity.Role{role}, pid, sid, fn)
	if len(ids) == 1 {
		return ids[0]
	}
	panic("插入失败, 仅返回一条记录时成功")
}

func (ag *autoGen) BatchInsertWithFunc(tx *sql.Tx, roles []*entity.Role, pid, sid int64, fn func(f any) bool) []int64 {

	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) DeleteByID(tx *sql.Tx, id int64) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) DeleteByIDs(tx *sql.Tx, ids ...int64) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) BatchDeleteByID(tx *sql.Tx, ids []int64) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) UpdateByID(tx *sql.Tx, role *entity.Role) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) UpdateNonNilByID(tx *sql.Tx, role *entity.Role) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) UpdateWithFuncByID(tx *sql.Tx, role *entity.Role, fn func(f any) bool) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) BatchUpdateWithFuncByID(tx *sql.Tx, roles []*entity.Role, fn func(f any) bool) bool {
	// TODO implement me
	panic("implement me")
}

func (ag *autoGen) SwitchNode(fromId, toId int64) bool {
	// TODO implement me
	panic("implement me")
}
