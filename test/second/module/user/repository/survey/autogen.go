// Code generated by tabuyos. DO NOT EDIT!

// Package survey
// @author tabuyos
// @since 2023/07/30
// @description survey
package survey

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"metis/config/constant"
	"metis/database"
	"metis/test/first/entity"
	"metis/util"
	"metis/util/logger"
	"strings"
)

type IAutoGen interface {
	SelectByID(id int64) entity.Survey
	SelectByIDs(ids ...int64) []entity.Survey
	BatchSelectByID(ids []int64) []entity.Survey

	Insert(tx *sql.Tx, survey *entity.Survey) int64
	BatchInsert(tx *sql.Tx, surveys []*entity.Survey) []int64
	InsertNonNil(tx *sql.Tx, survey *entity.Survey) int64
	InsertWithFunc(tx *sql.Tx, survey *entity.Survey, fn func(f any) bool) int64
	BatchInsertWithFunc(tx *sql.Tx, surveys []*entity.Survey, fn func(f any) bool) []int64

	DeleteByID(tx *sql.Tx, id int64) bool
	DeleteByIDs(tx *sql.Tx, ids ...int64) bool
	BatchDeleteByID(tx *sql.Tx, ids []int64) bool

	UpdateByID(tx *sql.Tx, survey *entity.Survey) bool
	UpdateNonNilByID(tx *sql.Tx, survey *entity.Survey) bool
	UpdateWithFuncByID(tx *sql.Tx, survey *entity.Survey, fn func(f any) bool) bool
	BatchUpdateWithFuncByID(tx *sql.Tx, surveys []*entity.Survey, fn func(f any) bool) bool
}
type autoGen struct {
	ctx *gin.Context
}

func (ag *autoGen) getDbCtx() context.Context {
	return context.WithValue(context.Background(), constant.TraceIdKey, ag.ctx.GetString(constant.TraceIdKey))
}
func (ag *autoGen) SelectByID(id int64) entity.Survey {
	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()
	sqlPlaceholder := "SELECT id, title, start_at FROM survey WHERE id = ?;"
	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	row := prepare.QueryRowContext(ag.getDbCtx(), id)
	survey := util.Row(row, mapperAll)
	return survey
}
func (ag *autoGen) SelectByIDs(ids ...int64) []entity.Survey {
	return ag.BatchSelectByID(ids)
}
func (ag *autoGen) BatchSelectByID(ids []int64) []entity.Survey {
	placeholder := make([]string, len(ids))
	for i := 0; i < len(ids); i++ {
		placeholder[i] = "?"
	}
	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()
	sqlPlaceholder := fmt.Sprintf("SELECT id, title, start_at FROM survey WHERE id = (%s);", strings.Join(placeholder, ", "))
	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	bindValues := make([]any, len(ids))
	for i, id := range ids {
		bindValues[i] = id
	}
	rows, err := prepare.QueryContext(ag.getDbCtx(), bindValues...)
	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}
	surveys := util.Rows(rows, mapperAll)
	return surveys
}
func (ag *autoGen) internalInsert(prepare *sql.Stmt, survey *entity.Survey) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	result, err := prepare.ExecContext(ag.getDbCtx(), *survey.ID, *survey.Title, *survey.StartAt)
	util.PanicErr(recorder, err)
	id, err := result.LastInsertId()
	util.PanicErr(recorder, err)
	return id
}
func (ag *autoGen) Insert(tx *sql.Tx, survey *entity.Survey) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "INSERT INTO survey(id, title, start_at) VALUES (?, ?, ?);"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	return ag.internalInsert(prepare, survey)
}
func (ag *autoGen) BatchInsert(tx *sql.Tx, surveys []*entity.Survey) []int64 {
	retids := make([]int64, len(surveys))
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "INSERT INTO survey(id, title, start_at) VALUES (?, ?, ?);"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	for i, survey := range surveys {
		retids[i] = ag.internalInsert(prepare, survey)
	}
	return retids
}
func (ag *autoGen) InsertNonNil(tx *sql.Tx, survey *entity.Survey) int64 {
	return ag.InsertWithFunc(tx, survey, func(f any) bool {
		return f != nil
	})
}
func (ag *autoGen) InsertWithFunc(tx *sql.Tx, survey *entity.Survey, fn func(f any) bool) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	var needField strings.Builder
	var needPlace strings.Builder
	var bindValue []any
	if fn(survey.ID) {
		needField.WriteString("id, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *survey.ID)
	}
	if fn(survey.Title) {
		needField.WriteString("title, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *survey.Title)
	}
	if fn(survey.StartAt) {
		needField.WriteString("start_at, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *survey.StartAt)
	}
	sqlPlaceholder := fmt.Sprintf("INSERT INTO survey(%s) VALUES (%s);", needField.String()[:needField.Len()-2], needPlace.String()[:needPlace.Len()-2])
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	return ag.internalInsert(prepare, survey)
}
func (ag *autoGen) BatchInsertWithFunc(tx *sql.Tx, surveys []*entity.Survey, fn func(f any) bool) []int64 {
	retids := make([]int64, len(surveys))
	for i, survey := range surveys {
		retids[i] = ag.InsertWithFunc(tx, survey, fn)
	}
	return retids
}
func (ag *autoGen) DeleteByID(tx *sql.Tx, id int64) bool {
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "UPDATE surveySET deleted = 1 WHERE id = ?;"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	result, err := prepare.ExecContext(ag.getDbCtx(), id)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == 1
}
func (ag *autoGen) DeleteByIDs(tx *sql.Tx, ids ...int64) bool {
	return ag.BatchDeleteByID(tx, ids)
}
func (ag *autoGen) BatchDeleteByID(tx *sql.Tx, ids []int64) bool {
	placeholder := make([]string, len(ids))
	for i := 0; i < len(ids); i++ {
		placeholder[i] = "?"
	}
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := fmt.Sprintf("UPDATE surveySET deleted = 1 WHERE id IN (%s);", strings.Join(placeholder, ", "))
	prepare, _ := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	bindValues := make([]any, len(ids))
	for i, id := range ids {
		bindValues[i] = id
	}
	result, err := prepare.ExecContext(ag.getDbCtx(), bindValues...)
	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == int64(len(ids))
}
func (ag *autoGen) UpdateByID(tx *sql.Tx, survey *entity.Survey) bool {
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "UPDATE survey SET id = ?, title = ?, start_at = ? WHERE id IN ?;"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	result, err := prepare.ExecContext(ag.getDbCtx(), *survey.ID, *survey.Title, *survey.StartAt)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == 1
}
func (ag *autoGen) UpdateNonNilByID(tx *sql.Tx, survey *entity.Survey) bool {
	return ag.UpdateWithFuncByID(tx, survey, func(f any) bool {
		return f == nil
	})
}
func (ag *autoGen) UpdateWithFuncByID(tx *sql.Tx, survey *entity.Survey, fn func(f any) bool) bool {
	recorder := logger.AccessLogger(ag.ctx)
	if survey.ID == nil {
		util.PanicErr(recorder, errors.New("ID is nil"))
	}
	var needFieldAndPlace strings.Builder
	var bindValue []any
	if fn(survey.Title) {
		needFieldAndPlace.WriteString("title = ?, ")
		bindValue = append(bindValue, *survey.Title)
	}
	if fn(survey.StartAt) {
		needFieldAndPlace.WriteString("start_at = ?, ")
		bindValue = append(bindValue, *survey.StartAt)
	}
	bindValue = append(bindValue, *survey.ID)
	sqlPlaceholder := fmt.Sprintf("UPDATE survey SET %s WHERE id = ?;", needFieldAndPlace.String()[:needFieldAndPlace.Len()-2])
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	result, err := prepare.ExecContext(ag.getDbCtx(), bindValue...)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == 1
}
func (ag *autoGen) BatchUpdateWithFuncByID(tx *sql.Tx, surveys []*entity.Survey, fn func(f any) bool) bool {
	recorder := logger.AccessLogger(ag.ctx)
	af := false
	for _, survey := range surveys {
		af = ag.UpdateWithFuncByID(tx, survey, fn)
		if af {
			continue
		}
		util.PanicErr(recorder, errors.New("some entry update failed"))
		break
	}
	return af
}
func mapperAll() (*entity.Survey, []any) {
	var r = &entity.Survey{}
	var cs = []any{&r.ID, &r.Title, &r.StartAt}
	return r, cs
}
