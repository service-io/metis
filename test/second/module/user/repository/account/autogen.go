// Code generated by tabuyos. DO NOT EDIT!

// Package account
// @author tabuyos
// @since 2023/07/30
// @description account
package account

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"metis/config/constant"
	"metis/database"
	"metis/test/first/entity"
	"metis/test/first/model/dto"
	"metis/util"
	"metis/util/logger"
	"strings"
)

type IAutoGen interface {
	SelectByID(id int64) dto.Account
	SelectByIDs(ids ...int64) []dto.Account
	BatchSelectByID(ids []int64) []dto.Account

	Insert(tx *sql.Tx, account *entity.Account) int64
	BatchInsert(tx *sql.Tx, accounts []*entity.Account) []int64
	InsertNonNil(tx *sql.Tx, account *entity.Account) int64
	InsertWithFunc(tx *sql.Tx, account *entity.Account, fn func(f any) bool) int64
	BatchInsertWithFunc(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) []int64

	DeleteByID(tx *sql.Tx, id int64) bool
	DeleteByIDs(tx *sql.Tx, ids ...int64) bool
	BatchDeleteByID(tx *sql.Tx, ids []int64) bool

	UpdateByID(tx *sql.Tx, account *entity.Account) bool
	UpdateNonNilByID(tx *sql.Tx, account *entity.Account) bool
	UpdateWithFuncByID(tx *sql.Tx, account *entity.Account, fn func(f any) bool) bool
	BatchUpdateWithFuncByID(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) bool
}
type autoGen struct {
	ctx *gin.Context
}

func (ag *autoGen) getDbCtx() context.Context {
	return context.WithValue(context.Background(), constant.TraceIdKey, ag.ctx.GetString(constant.TraceIdKey))
}
func (ag *autoGen) SelectByID(id int64) dto.Account {
	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()
	sqlPlaceholder := "SELECT id, title, start_at FROM account WHERE id = ?;"
	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	row := prepare.QueryRowContext(ag.getDbCtx(), id)
	account := util.Row(row, mapperAll)
	return account
}
func (ag *autoGen) SelectByIDs(ids ...int64) []dto.Account {
	return ag.BatchSelectByID(ids)
}
func (ag *autoGen) BatchSelectByID(ids []int64) []dto.Account {
	placeholder := make([]string, len(ids))
	for i := 0; i < len(ids); i++ {
		placeholder[i] = "?"
	}
	recorder := logger.AccessLogger(ag.ctx)
	db := database.FetchDB()
	sqlPlaceholder := fmt.Sprintf("SELECT id, title, start_at FROM account WHERE id = (%s);", strings.Join(placeholder, ", "))
	prepare, _ := db.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	bindValues := make([]any, len(ids))
	for i, id := range ids {
		bindValues[i] = id
	}
	rows, err := prepare.QueryContext(ag.getDbCtx(), bindValues...)
	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}
	accounts := util.Rows(rows, mapperAll)
	return accounts
}
func (ag *autoGen) internalInsert(prepare *sql.Stmt, account *entity.Account) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	result, err := prepare.ExecContext(ag.getDbCtx(), *account.ID, *account.Title, *account.StartAt)
	util.PanicErr(recorder, err)
	id, err := result.LastInsertId()
	util.PanicErr(recorder, err)
	return id
}
func (ag *autoGen) Insert(tx *sql.Tx, account *entity.Account) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "INSERT INTO account(id, title, start_at) VALUES (?, ?, ?);"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	return ag.internalInsert(prepare, account)
}
func (ag *autoGen) BatchInsert(tx *sql.Tx, accounts []*entity.Account) []int64 {
	retids := make([]int64, len(accounts))
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "INSERT INTO account(id, title, start_at) VALUES (?, ?, ?);"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	for i, account := range accounts {
		retids[i] = ag.internalInsert(prepare, account)
	}
	return retids
}
func (ag *autoGen) InsertNonNil(tx *sql.Tx, account *entity.Account) int64 {
	return ag.InsertWithFunc(tx, account, func(f any) bool {
		return f != nil
	})
}
func (ag *autoGen) InsertWithFunc(tx *sql.Tx, account *entity.Account, fn func(f any) bool) int64 {
	recorder := logger.AccessLogger(ag.ctx)
	var needField strings.Builder
	var needPlace strings.Builder
	var bindValue []any
	if fn(account.ID) {
		needField.WriteString("id, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *account.ID)
	}
	if fn(account.Title) {
		needField.WriteString("title, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *account.Title)
	}
	if fn(account.StartAt) {
		needField.WriteString("start_at, ")
		needPlace.WriteString("?, ")
		bindValue = append(bindValue, *account.StartAt)
	}
	sqlPlaceholder := fmt.Sprintf("INSERT INTO account(%s) VALUES (%s);", needField.String()[:needField.Len()-2], needPlace.String()[:needPlace.Len()-2])
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	return ag.internalInsert(prepare, account)
}
func (ag *autoGen) BatchInsertWithFunc(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) []int64 {
	retids := make([]int64, len(accounts))
	for i, account := range accounts {
		retids[i] = ag.InsertWithFunc(tx, account, fn)
	}
	return retids
}
func (ag *autoGen) DeleteByID(tx *sql.Tx, id int64) bool {
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "UPDATE accountSET deleted = 1 WHERE id = ?;"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	result, err := prepare.ExecContext(ag.getDbCtx(), id)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == 1
}
func (ag *autoGen) DeleteByIDs(tx *sql.Tx, ids ...int64) bool {
	return ag.BatchDeleteByID(tx, ids)
}
func (ag *autoGen) BatchDeleteByID(tx *sql.Tx, ids []int64) bool {
	placeholder := make([]string, len(ids))
	for i := 0; i < len(ids); i++ {
		placeholder[i] = "?"
	}
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := fmt.Sprintf("UPDATE accountSET deleted = 1 WHERE id IN (%s);", strings.Join(placeholder, ", "))
	prepare, _ := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	bindValues := make([]any, len(ids))
	for i, id := range ids {
		bindValues[i] = id
	}
	result, err := prepare.ExecContext(ag.getDbCtx(), bindValues...)
	if err != nil {
		recorder.Error(err.Error(), zap.Error(err))
	}
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == int64(len(ids))
}
func (ag *autoGen) UpdateByID(tx *sql.Tx, account *entity.Account) bool {
	recorder := logger.AccessLogger(ag.ctx)
	sqlPlaceholder := "UPDATE account SET id = ?, title = ?, start_at = ? WHERE id IN ?;"
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	result, err := prepare.ExecContext(ag.getDbCtx(), *account.ID, *account.Title, *account.StartAt)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == 1
}
func (ag *autoGen) UpdateNonNilByID(tx *sql.Tx, account *entity.Account) bool {
	return ag.UpdateWithFuncByID(tx, account, func(f any) bool {
		return f == nil
	})
}
func (ag *autoGen) UpdateWithFuncByID(tx *sql.Tx, account *entity.Account, fn func(f any) bool) bool {
	recorder := logger.AccessLogger(ag.ctx)
	if account.ID == nil {
		util.PanicErr(recorder, errors.New("ID is nil"))
	}
	var needFieldAndPlace strings.Builder
	var bindValue []any
	if fn(account.Title) {
		needFieldAndPlace.WriteString("title = ?, ")
		bindValue = append(bindValue, *account.Title)
	}
	if fn(account.StartAt) {
		needFieldAndPlace.WriteString("start_at = ?, ")
		bindValue = append(bindValue, *account.StartAt)
	}
	bindValue = append(bindValue, *account.ID)
	sqlPlaceholder := fmt.Sprintf("UPDATE account SET %s WHERE id = ?;", needFieldAndPlace.String()[:needFieldAndPlace.Len()-2])
	prepare, err := tx.Prepare(sqlPlaceholder)
	defer util.DeferClose(prepare, util.ErrToLog(recorder))
	util.PanicErr(recorder, err)
	result, err := prepare.ExecContext(ag.getDbCtx(), bindValue...)
	util.PanicErr(recorder, err)
	af, err := result.RowsAffected()
	util.PanicErr(recorder, err)
	return af == 1
}
func (ag *autoGen) BatchUpdateWithFuncByID(tx *sql.Tx, accounts []*entity.Account, fn func(f any) bool) bool {
	recorder := logger.AccessLogger(ag.ctx)
	af := false
	for _, account := range accounts {
		af = ag.UpdateWithFuncByID(tx, account, fn)
		if af {
			continue
		}
		util.PanicErr(recorder, errors.New("some entry update failed"))
		break
	}
	return af
}
func mapperAll() (*dto.Account, []any) {
	var r = &dto.Account{}
	var cs = []any{&r.ID, &r.Title, &r.StartAt}
	return r, cs
}
